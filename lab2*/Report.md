# **Лабораторная работа 2 со здвездочкой**
В данной работе используется Docker Compose для развертывания двух контейнеров: один с Python-приложением, использующим библиотеку pymongo для взаимодействия с БД, второй — с MongoDB. Цель задания — выявить и исправить три "плохие практики" при написании Docker Compose файлов, а также настроить изоляцию между контейнерами, чтобы они не могли взаимодействовать друг с другом по сети.

## **Пример плохого docker-compose**

```yaml
version: '3'

services:
  app:
    build: ./app

  mongo:
    image: mongo:latest
```
## **Пoяснение**
1. Использование `latest` версий может привести к проблемам в будущем, если выйдет несовместимое обновление MongoDB. Оптимальным решением будет указание конкретной версии образа MongoDB.

2. Рекомендуется использовать директиву `depends_on`, которая гарантирует, что контейнер с MongoDB запустится раньше, чем контейнер с приложением, что предотвратит возникновение ошибок при подключении.

3. По-хорошему, нужно использовать директивы `deploy.resources.limits`, чтобы задать конкретные ограничения на использование ресурсов для каждого контейнера. 

## **Исправленный docker-compose**

```yaml
version: '3'

services:
  app:
    build: ./app
    depends_on:
      - mongo
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: 512M
  mongo:
    image: mongo:4.4
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: 512M
```

## **Изоляция контейнеров**
Необходимо создать две отдельные сети для каждого контейнера: это предотвращает прямое взаимодействие между ними, так как при запуске контейнеров через docker-compose, контейнеры по умолчанию помещаются в одну сеть.
В директиве `networks` для каждого контейнера пропишем `app-net` и `mongo-net` соотетсвенно.
```yaml
version: '3'

services:
  app:
    build: ./app
    depends_on:
      - mongo
    networks:
      - app-net
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: 512M
  mongo:
    image: mongo:4.4
    networks:
      - mongo-net
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: 512M
networks:
  app-net:
    driver: bridge
  mongo-net:
    driver: bridge
```
Для того, чтоб убедиться, что контейнеры изолированы друг от друга, попробуем пинговать контейнер `mongo` из котейнера `app`:
1. Применим все изменения к контейнерам через `docker compose build`
2. Запустим оба контейнера в фоновом режиме с помоью команды `docker compose up -d`
3. Подключимся к оболочке sh первого контейнера введя комнаду `docker compose exec app sh`
4. Попробуем пинговать контейнер с MongoDB, с помощью команды `ping momgo`
